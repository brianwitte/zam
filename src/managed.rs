// SPDX-License-Identifier: Apache-2.0

use std::fs;
use std::path::PathBuf;

use crate::alias::types::{AliasSource, ManagedError};

/// Root of the managed directory: ~/.config/zam/
pub fn managed_dir() -> Option<PathBuf> {
    dirs::home_dir().map(|h| h.join(".config/zam"))
}

/// Create the managed directory tree if it doesn't exist.
pub fn ensure_dirs() -> Result<(), ManagedError> {
    let base = managed_dir().ok_or(ManagedError::CreateDir(std::io::Error::new(
        std::io::ErrorKind::NotFound,
        "home directory not found",
    )))?;
    fs::create_dir_all(base.join("aliases")).map_err(ManagedError::CreateDir)?;
    fs::create_dir_all(base.join("overrides")).map_err(ManagedError::CreateDir)?;
    Ok(())
}

/// Full init: create dirs, write init.zsh, add source line to ~/.zshrc.
pub fn init() -> Result<(), ManagedError> {
    ensure_dirs()?;

    let base = managed_dir().unwrap();
    let init_path = base.join("init.zsh");

    let init_content = "\
# zam managed aliases â€” sourced from ~/.zshrc
# Do not edit this file; it is regenerated by `zam --init`.

for f in ~/.config/zam/aliases/*.zsh(N); do source \"$f\"; done
for f in ~/.config/zam/overrides/*.zsh(N); do source \"$f\"; done

# Shell wrapper: re-source aliases after zam modifies them
zam() {
    command zam \"$@\"
    local ret=$?
    [ $ret -eq 0 ] && source ~/.config/zam/init.zsh
    return $ret
}
";

    fs::write(&init_path, init_content).map_err(ManagedError::WriteFile)?;

    // Append source line to ~/.zshrc (idempotent)
    let Some(home) = dirs::home_dir() else {
        return Err(ManagedError::CreateDir(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "home directory not found",
        )));
    };
    let zshrc_path = home.join(".zshrc");
    let source_line = "source ~/.config/zam/init.zsh";

    let existing = fs::read_to_string(&zshrc_path).unwrap_or_default();
    if !existing.lines().any(|l| l.trim() == source_line) {
        let mut content = existing;
        if !content.ends_with('\n') && !content.is_empty() {
            content.push('\n');
        }
        content.push_str(source_line);
        content.push('\n');
        fs::write(&zshrc_path, content).map_err(ManagedError::WriteFile)?;
    }

    Ok(())
}

/// Delete ~/.config/zam/ entirely and remove the source line from ~/.zshrc.
pub fn nuke() -> Result<(), ManagedError> {
    let Some(base) = managed_dir() else {
        return Ok(());
    };

    if base.is_dir() {
        fs::remove_dir_all(&base).map_err(ManagedError::CreateDir)?;
    }

    // Remove source line from ~/.zshrc
    let Some(home) = dirs::home_dir() else {
        return Ok(());
    };
    let zshrc_path = home.join(".zshrc");
    let source_line = "source ~/.config/zam/init.zsh";

    if let Ok(content) = fs::read_to_string(&zshrc_path) {
        let filtered: Vec<&str> = content
            .lines()
            .filter(|l| l.trim() != source_line)
            .collect();
        let mut output = filtered.join("\n");
        if !output.is_empty() && !output.ends_with('\n') {
            output.push('\n');
        }
        fs::write(&zshrc_path, output).map_err(ManagedError::WriteFile)?;
    }

    Ok(())
}

/// Check whether the managed directory is initialized.
pub fn is_initialized() -> bool {
    managed_dir()
        .map(|base| base.join("init.zsh").is_file())
        .unwrap_or(false)
}

/// Validate an alias name: non-empty, no whitespace, no '=' or quotes.
pub fn validate_alias_name(name: &str) -> Result<(), ManagedError> {
    if name.is_empty() {
        return Err(ManagedError::EmptyName);
    }
    if name.contains(|c: char| c.is_whitespace() || c == '=' || c == '\'' || c == '"') {
        return Err(ManagedError::InvalidName(name.to_string()));
    }
    Ok(())
}

/// Shell-safe single-quoting: wrap in single quotes, escape embedded
/// single quotes with the '\'' idiom.
pub fn shell_quote(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 2);
    out.push('\'');
    for c in s.chars() {
        if c == '\'' {
            out.push_str("'\\''");
        } else {
            out.push(c);
        }
    }
    out.push('\'');
    out
}

/// Format a single alias line: `alias name='command'`
pub fn format_alias_line(name: &str, command: &str) -> String {
    format!("alias {}={}", name, shell_quote(command))
}

/// Generate a slug from an AliasSource for override filenames.
pub fn source_slug(source: &AliasSource) -> String {
    match source {
        AliasSource::OhMyZshPlugin(name) => format!("oh-my-zsh-plugin-{name}"),
        AliasSource::OhMyZshLib(name) => {
            format!("oh-my-zsh-lib-{}", name.trim_end_matches(".zsh"))
        }
        AliasSource::OhMyZshCustom(name) => {
            format!("oh-my-zsh-custom-{}", name.trim_end_matches(".zsh"))
        }
        AliasSource::Zshrc => "zshrc".to_string(),
        AliasSource::ZamExtension(name) => format!("ext-{name}"),
        AliasSource::ZamCustom => "custom".to_string(),
        AliasSource::ZamOverride(slug) => slug.clone(),
        AliasSource::Unknown => "unknown".to_string(),
    }
}

fn custom_file_path() -> Result<PathBuf, ManagedError> {
    let base = managed_dir().ok_or(ManagedError::NotInitialized)?;
    Ok(base.join("aliases/custom.zsh"))
}

fn override_file_path(slug: &str) -> Result<PathBuf, ManagedError> {
    let base = managed_dir().ok_or(ManagedError::NotInitialized)?;
    Ok(base.join(format!("overrides/{slug}.zsh")))
}

/// Write (append or update) a custom alias to custom.zsh.
pub fn write_custom_alias(name: &str, command: &str) -> Result<(), ManagedError> {
    if !is_initialized() {
        return Err(ManagedError::NotInitialized);
    }
    validate_alias_name(name)?;

    let path = custom_file_path()?;
    let new_line = format_alias_line(name, command);

    let content = fs::read_to_string(&path).unwrap_or_default();
    let prefix = format!("alias {name}=");

    let mut found = false;
    let mut lines: Vec<String> = content
        .lines()
        .map(|line| {
            if line.starts_with(&prefix) {
                found = true;
                new_line.clone()
            } else {
                line.to_string()
            }
        })
        .collect();

    if !found {
        lines.push(new_line);
    }

    let mut output = lines.join("\n");
    if !output.ends_with('\n') {
        output.push('\n');
    }

    fs::write(&path, output).map_err(ManagedError::WriteFile)
}

/// Write an override alias to the appropriate override file.
pub fn write_override(
    name: &str,
    command: &str,
    source: &AliasSource,
) -> Result<(), ManagedError> {
    if !is_initialized() {
        return Err(ManagedError::NotInitialized);
    }
    validate_alias_name(name)?;

    let slug = source_slug(source);
    let path = override_file_path(&slug)?;
    let new_line = format_alias_line(name, command);

    let content = fs::read_to_string(&path).unwrap_or_default();
    let prefix = format!("alias {name}=");
    let unalias_line = format!("unalias {name} 2>/dev/null");

    let mut found = false;
    let mut lines: Vec<String> = content
        .lines()
        .filter(|line| line.trim() != unalias_line) // remove any existing unalias
        .map(|line| {
            if line.starts_with(&prefix) {
                found = true;
                new_line.clone()
            } else {
                line.to_string()
            }
        })
        .collect();

    if !found {
        lines.push(new_line);
    }

    let mut output = lines.join("\n");
    if !output.ends_with('\n') {
        output.push('\n');
    }

    fs::write(&path, output).map_err(ManagedError::WriteFile)
}

/// Delete a custom alias from custom.zsh.
pub fn delete_custom_alias(name: &str) -> Result<(), ManagedError> {
    if !is_initialized() {
        return Err(ManagedError::NotInitialized);
    }

    let path = custom_file_path()?;
    let content = fs::read_to_string(&path).unwrap_or_default();
    let prefix = format!("alias {name}=");

    let lines: Vec<&str> = content
        .lines()
        .filter(|line| !line.starts_with(&prefix))
        .collect();

    let mut output = lines.join("\n");
    if !output.is_empty() && !output.ends_with('\n') {
        output.push('\n');
    }

    fs::write(&path, output).map_err(ManagedError::WriteFile)
}

fn extension_file_path(name: &str) -> Result<PathBuf, ManagedError> {
    let base = managed_dir().ok_or(ManagedError::NotInitialized)?;
    Ok(base.join(format!("aliases/{name}.zsh")))
}

/// Write an extension alias file with all aliases and comments.
pub fn install_extension(
    name: &str,
    aliases: &[(&str, &str, &str)],
) -> Result<(), ManagedError> {
    if !is_initialized() {
        return Err(ManagedError::NotInitialized);
    }

    let path = extension_file_path(name)?;
    let mut output = format!("# zam extension: {name}\n\n");
    for &(alias_name, command, comment) in aliases {
        output.push_str(&format!("# {comment}\n"));
        output.push_str(&format_alias_line(alias_name, command));
        output.push('\n');
    }

    fs::write(&path, output).map_err(ManagedError::WriteFile)
}

/// Remove an installed extension by deleting its alias file.
pub fn remove_extension(name: &str) -> Result<(), ManagedError> {
    let path = extension_file_path(name)?;
    if path.is_file() {
        fs::remove_file(&path).map_err(ManagedError::WriteFile)?;
    }
    Ok(())
}

/// Check whether an extension is installed.
pub fn is_extension_installed(name: &str) -> bool {
    extension_file_path(name)
        .map(|p| p.is_file())
        .unwrap_or(false)
}

/// Delete a plugin/system alias by writing `unalias` to the override file.
pub fn delete_override(name: &str, source: &AliasSource) -> Result<(), ManagedError> {
    if !is_initialized() {
        return Err(ManagedError::NotInitialized);
    }

    let slug = source_slug(source);
    let path = override_file_path(&slug)?;
    let unalias_line = format!("unalias {name} 2>/dev/null");

    let content = fs::read_to_string(&path).unwrap_or_default();

    // Don't add duplicate unalias lines
    if content.lines().any(|l| l.trim() == unalias_line) {
        return Ok(());
    }

    // Also remove any existing override alias for this name
    let prefix = format!("alias {name}=");
    let mut lines: Vec<&str> = content
        .lines()
        .filter(|line| !line.starts_with(&prefix))
        .collect();

    lines.push(&unalias_line);

    let mut output = lines.join("\n");
    if !output.ends_with('\n') {
        output.push('\n');
    }

    fs::write(&path, output).map_err(ManagedError::WriteFile)
}
